#include "arduino_secrets.h"
// MAX3010x Sensor Library - Version: Latest
#include <MAX3010x.h>
#include "filters.h"

/*
  DOCUMENTACION SPO2:

  https://devxplained.eu/en/blog/max3010x-pulse-oximeter-modules-part-4

  https://devxplained.eu/en/blog/max3010x-pulse-oximeter-modules-part-4#f91f3277390

*/

// OneWire - Version: Latest
#include <OneWire.h>

// DallasTemperature - Version: Latest
#include <DallasTemperature.h>


/******************************************************************************
  HealthBox_Patient.ino
  Program for Laboratorio de Bioinstrumentacion
  Grupo 3

  Authors:

  Beatriz Arroyo Juárez
  Elsa Aragón Abad
  Ana Barato Abad
  Lucia Cano Coronado
  Elisa Dovier
  Miguel Grande
  Sofía Kools

  Resources:
    This program requires a Processing sketch to view the data in real time.
    This program also needs some libraries

  Development environment specifics:
    IDE: Arduino Online Editor (lastest version)
    Hardware Platform: Arduino ESP32 3.3V/8MHz
    HealthBox Version: 1.0

   ******************************************************************************/

/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/13affe90-6ab3-4594-918b-617ba15d671d

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float temperatura;
  int value_heartRate;
  int value_spo2;
  bool readSPO2_Button;
  bool readTemperature_Button;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// Incluimos el thingProperties que configura el THING en IoT Cloud
#include "thingProperties.h"


// -TEMPERATURE ONE WIRE VARIBALES--------------------------------------------------------
#define ONE_WIRE_BUS 5                // Definimos el pin al que hemos conectado la comunicación OneWire
OneWire oneWire(ONE_WIRE_BUS);        // Configuramos una instancia OneWire
DallasTemperature sensorT(&oneWire);  // Pasamos la referencia de OneWire a DallasTemperature

// -OXIMETER VARIBALES--------------------------------------------------------------------
MAX30102 sensorO2;

const auto kSamplingRate = sensorO2.SAMPLING_RATE_400SPS;
const float kSamplingFrequency = 400.0;

// Finger Detection Threshold and Cooldown
const unsigned long kFingerThreshold = 10000;
const unsigned int kFingerCooldownMs = 500;

// Edge Detection Threshold (decrease for MAX30100)
const float kEdgeThreshold = -2000.0;

// Filters
const float kLowPassCutoff = 5.0;
const float kHighPassCutoff = 0.5;

// Averaging
const bool kEnableAveraging = true;
const int kAveragingSamples = 50;
const int kSampleThreshold = 5;


// -PINS SETUPS--------------------------------------------------------------------------
void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();


  // Sensor de temperatura lo inicializa la librería Dallas
  sensorT.begin();

  // PULSIOXIMETER SETUP
  if (sensorO2.begin() && sensorO2.setSamplingRate(kSamplingRate)) {
    Serial.println("Sensor initialized");
  }
  else {
    Serial.println("Sensor not found");
    while(1);
  }

}

  // - PULSIOXIMETER INSTANCES --------------------------------------------------------
  
  // Instanciamos los filtros que modularán la señal:
  HighPassFilter high_pass_filter(kHighPassCutoff, kSamplingFrequency);
  LowPassFilter low_pass_filter_red(kLowPassCutoff, kSamplingFrequency);
  LowPassFilter low_pass_filter_ir(kLowPassCutoff, kSamplingFrequency);
  Differentiator differentiator(kSamplingFrequency);
  MovingAverageFilter<kAveragingSamples> averager_bpm;
  MovingAverageFilter<kAveragingSamples> averager_r;
  MovingAverageFilter<kAveragingSamples> averager_spo2;
  
  // FALTAN LAS STATISTIS (NO SE HASTA QUE PUNTO SON NECESARIAS)
  //??????????????
  MinMaxAvgStatistic stat_red;
  MinMaxAvgStatistic stat_ir;
  
  // R value to SpO2 calibration factors
  // See https://www.maximintegrated.com/en/design/technical-documents/app-notes/6/6845.html
  float kSpO2_A = 1.5958422;
  float kSpO2_B = -34.6596622;
  float kSpO2_C = 112.6898759;
  
  // Variables para Medidor de Heatrbeat (globales):
  //Timestamp of the last heartbeat
  long last_heartbeat = 0;
  
  // Timestamp for finger detection
  long finger_timestamp = 0;
  bool finger_detected = false;
  
  // Last diff to detect zero crossing
  float last_diff = NAN;
  bool crossed = false;
  long crossed_time = 0;
  
  // - CODE STATES LOOP ---------------------------------------------------------------
  void loop() {
    ArduinoCloud.update();
    
    temperatura = 36.8;
    value_heartRate = 87;
    value_spo2= 93;
  }
  
  //- FUNCTIONS THAT GET THE BIOMETRIC SIGNALS----------------------------------------
  
  
  /*
     Funciones para PULSIOXIMETRO:
  */
  
  // Checkea si el dedo está puesto o no, el estado de detección del dedo se guarda en una variable global llamada "finger_detected"
  void get_finger_state() {
    Serial.println("Entra en get finger state line 186");
    auto sample = sensorO2.readSample(1000);
    float current_value = sample.red;
  
    // Detect Finger using raw sensor value
    if (sample.red > kFingerThreshold) {
      if (millis() - finger_timestamp > kFingerCooldownMs) {
        Serial.println("Detecta el dedo line 194");
        finger_detected = true;
      }
    } else {
      differentiator.reset();
      
      averager_bpm.reset();
      averager_r.reset();
      averager_spo2.reset();
      
      low_pass_filter_red.reset();
      low_pass_filter_ir.reset();
      high_pass_filter.reset();
      
      stat_red.reset();
      stat_ir.reset();
      
      finger_detected = false;
      finger_timestamp = millis();
    }
  }
  
  
  int get_spo2_hr(int mode) {
    Serial.println("Entra en funcion get_spo2_hr");
    
    while (1) {
      auto sample = sensorO2.readSample(1000);
      float current_value_red = sample.red;
      float current_value_ir = sample.ir;
    
      get_finger_state();
      
      if (finger_detected) {
        current_value_red = low_pass_filter_red.process(current_value_red);
        current_value_ir = low_pass_filter_ir.process(current_value_ir);
        
        // Statistics for pulse oximetry
        stat_red.process(current_value_red);
        stat_ir.process(current_value_ir);
        
        // Heart beat detection using value for red LED
        float current_value = high_pass_filter.process(current_value_red);
        float current_diff = differentiator.process(current_value);
      
      
        // Valid values?
        if(!isnan(current_diff) && !isnan(last_diff)) {
        
        // Detect Heartbeat - Zero-Crossing
        if(last_diff > 0 && current_diff < 0) {
          crossed = true;
          crossed_time = millis();
        }
        
        if(current_diff > 0) {
          crossed = false;
        }
    
        // Detect Heartbeat - Falling Edge Threshold
        if(crossed && current_diff < kEdgeThreshold) {
          if(last_heartbeat != 0 && crossed_time - last_heartbeat > 300) {
            // Show Results
            int bpm = 60000/(crossed_time - last_heartbeat);
            float rred = (stat_red.maximum()-stat_red.minimum())/stat_red.average();
            float rir = (stat_ir.maximum()-stat_ir.minimum())/stat_ir.average();
            float r = rred/rir;
            float spo2 = kSpO2_A * r * r + kSpO2_B * r + kSpO2_C;
            
            if(bpm > 50 && bpm < 250) {
              // Average?
              if(kEnableAveraging) {
                int average_bpm = averager_bpm.process(bpm);
                int average_r = averager_r.process(r);
                int average_spo2 = averager_spo2.process(spo2);
    
                // Show if enough samples have been collected
                if(averager_bpm.count() >= kSampleThreshold) {
                  Serial.print("Time (ms): ");
                  Serial.println(millis()); 
                  Serial.print("Heart Rate (avg, bpm): ");
                  Serial.println(average_bpm);
                  Serial.print("R-Value (avg): ");
                  Serial.println(average_r);  
                  Serial.print("SpO2 (avg, %): ");
                  Serial.println(average_spo2);  
                  if (mode = 1) return average_bpm;
                }
              }
              else {
                Serial.print("Time (ms): ");
                Serial.println(millis()); 
                Serial.print("Heart Rate (current, bpm): ");
                Serial.println(bpm);  
                Serial.print("R-Value (current): ");
                Serial.println(r);
                Serial.print("SpO2 (current, %): ");
                Serial.println(spo2);   
              }
            }
  
            // Reset statistic
            stat_red.reset();
            stat_ir.reset();
           }
    
            crossed = false;
            last_heartbeat = crossed_time;
          }
        }
        last_diff = current_diff;
      }
    }
  }
  
  /*
     Funciones para TERMOMETRO:
  */
  float get_instant_temperature() {
    sensorT.requestTemperatures();
    float tempC = sensorT.getTempCByIndex(0);
  
    if (tempC != DEVICE_DISCONNECTED_C) {
      return tempC;
    }
  }
  
  float calculate_temperature(long time_start) {
    // Recoge valores de temperatura cada 3ms durante 30 segundos y devuelve un valor
    float suma = 0.0;
    float cuenta_medidas = 0.0;
    float media = 0.0;
  
    Serial.println("Entro en bucle while");
  
    while (millis() <= time_start) {
      // lo que este aqui dentro tiene 60 segundos para ejecutarse
      // o puedes salir con break
  
      Serial.print("Sensor temp redond:");
      Serial.println(get_instant_temperature());
  
      suma = suma + get_instant_temperature();
      cuenta_medidas = cuenta_medidas + 1.0;
      delay(20);
    }
  
    Serial.println("Sale Bucle while");
    media = suma / cuenta_medidas; // No se los decimales que me va a dar esto, redondeo despues
  
    // Redondeo y devuelvo el valor
    double _potencia = pow(10, 1);
    return (roundf(media * _potencia) / _potencia);
  }
  
  
  /*
     INTERRUPCIONES Y CONTROL DEL PROCESO
  */
  
  /*
    Since ReadTemperatureButton is READ_WRITE variable, onReadTemperatureButtonChange() is
    executed every time a new value is received from IoT Cloud.
  */
  
  float temperatura_val;
  void onReadTemperatureButtonChange() {
  
    long time_start = millis() + 30000; // cargo a start con el valor +60mil milisegundos
  
    if (readTemperature_Button) {
      temperatura_val = calculate_temperature(time_start);
      Serial.print("Valor medido:");
      Serial.println(temperatura_val);
      if (temperatura_val > 0.0) {
        Serial.println("Actualizo al cloud temperatura");
        temperatura = temperatura_val;    // Para que no se ponga a cero cuando desconectamos.
      }
    }
  }
  
  
  /*
    Since ReadSPO2Button is READ_WRITE variable, onReadSPO2ButtonChange() is
    executed every time a new value is received from IoT Cloud.
  */
  
  void onReadSPO2ButtonChange()  {
  
    if (readSPO2_Button) {
      Serial.println("Entra funcion onReadSPO2ButtonChange");
      value_heartRate = get_spo2_hr(1); // Subimos el resultado a IOT Cloud
      readSPO2_Button = false; // Cuidado con esto 
    } else {
      
    }
  }
